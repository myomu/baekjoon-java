package dynamic1;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

/**
 * 10844번
 * 쉬운 계단 수
 */
public class Dynamic10 {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int MOD = 1_000_000_000;
        int N = Integer.parseInt(br.readLine());
        long[][] dp = new long[N + 1][10];
        dp[1] = new long[]{0, 1, 1, 1, 1, 1, 1, 1, 1, 1};
        for (int i = 2; i <= N; i++) {
            for (int j = 0; j < 10; j++) {
                if (j == 9) {
                    dp[i][j] = dp[i - 1][8] % MOD;
                } else if (j == 0) {
                    dp[i][j] = dp[i - 1][1] % MOD;
                } else {
                    dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j + 1]) % MOD;
                }
            }
        }
        //System.out.println(Arrays.toString(dp[N]));
        long result = Arrays.stream(dp[N]).sum() % MOD;
        System.out.print(result);
    }

}
// 배열 dp는 계단 수의 마지막 자리 수가 0~9이 되는 수의 집합의 개수라고 하자. 단, 첫 수로는 0 이 오지 못하므로 1단계는 [0, 1, 1, 1, 1, 1, 1, 1, 1, 1] 이 될것이다.
// 2단계는 10 이라는 수가 있으므로 0의 자리에는 1개가 된다. 1의 자리는 21 이라는 수가 있으므로 1개. 9는 89 밖에 오지 못하므로 1개.
// 결과적으로 [1, 1, 2, 2, 2, 2, 2, 2, 2, 1] 이 된다.
// 3단계는 0 -> 210 : 1개, 1 -> 321, 101, 121 : 3개 ... 이 법칙을 보면 0의 경우 21이라는 수가 붙는데 이것은 2 단계에서의 1번자리의 수를 말하고
// 1의 경우 2단계에서의 0(10)과 2(12, 32) 의 값을 합한 수가 됨으로
// dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]; 가 된다.
// 단, 0이나 9의 경우는 다르다.
// j == 9 일때, dp[i][j] = dp[i - 1][j - 1]; => dp[i - 1][8];
// j == 0 일때, dp[i][j] = dp[i - 1][j + 1]; => dp[i - 1][1]
// ==> !! 0으로 끝나는 수는 앞에 1로 끝나는 수밖에 오지 못하고 9로 끝나는 수는 앞에 8로 끝나는 수밖에 오지 못하기 때문이다.
// 10 억 으로 나누라는 것은 MOD 모듈러 연산을 말한다. 계산 도중 overflow 가 일어나 음수가 나올 수 있는 것을 방지하기 위함인듯하다.
// 계속 틀린 이유를 보니 int 형으로 진행해서 21억이 넘어가는 수에 대해 간과했던 것 같다. long 으로 자료형을 변경해서 문제를 해결했다.

// 1 - 1, 2, 3, 4, 5, 6, 7, 8, 9 (9개)
// 2 - 12, 23, 34, 45, 56, 67, 78, 89(증가) | 10, 21, 32, 43, 54, 65, 76, 87, 98(감소) (17개)
// 3 - 123, 234, 345, 456, 567, 678, 789(증가) | 121, 232, 343, 454, 565, 676, 787, 898(감소) | 15
// 210, 321, 432, 543, 654, 765, 876, 987(감소) | 101, 212, 323, 434, 545, 656, 767, 878, 989(증가) (15 + 17 = 32개)
// 4 - 1234, 2345, 3456, 4567, 5678, 6789 | 1232, 2343, 3454, 4565, 5676, 6787, 7898 | 1212, 2323, 3434, 4545, 5656, 6767, 7878, 8989 | 1210, 2321, 3432, 454 ...
