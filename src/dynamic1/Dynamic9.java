package dynamic1;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

/**
 * 1463번
 * 1로 만들기
 */
public class Dynamic9 {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());
        int size = 1_000_001;
        //int size = 20;
        int[] dp = new int[size];
        dp[1] = 0;
        dp[2] = 1;
        dp[3] = 1;

        for (int i = 4; i < size; i++) {
            int count = 1;
            if (i % 6 == 0) {
              dp[i] = Math.min(Math.min(dp[i / 3], dp[i / 2]), dp[i - 1]) + count;
            } else if (i % 3 == 0) {
                dp[i] = Math.min(dp[i / 3], dp[i - 1]) + count;
            } else if (i % 2 == 0) {
                dp[i] = Math.min(dp[i / 2], dp[i - 1]) + count;
            } else {
                dp[i] = dp[i - 1] + count;
            }
        }

        //System.out.println(Arrays.toString(dp));
        System.out.print(dp[N]);
    }

}

// 2와 3으로 나눠지지 않는 수는 5, 7, 11, 13, 17, 23... 같은 소수들이다. 소수들은 -1 을 하면 짝수가 된다.
// 2와 3의 최소공배수는 6. 6의 배수들은 2 또는 3으로 나눠지는 수다. 6의 배수는 짝수.
// 결국엔 이 문제도 최소의 경로를 찾아가는 방식으로 진행된다. 예를들어 10의 경우 9 의 최소 경로를, 9는 3의 최소 경로 값이 포함되어 있다.
// 2, 4, 6, 8, 10, 12, ... | 3, 6, 9, 12, 15, 18, 21, ... 이 법칙을 보면 3의 배수 중에는 2로 나눠지는 수 또는 -1을 하면 2의 배수가 되는 수만 존재한다.

// 반레 : 642, 정답 : 10
// 6의 배수인 경우는 dp 를 2로 나눈 것과 3으로 나눈 것중 작은 것을 선택해야 한다. <- 이 조건이 필요.
// 나는 3이 나눠지면 무조건 이득이라고 생각했었다. 그러나 그것이 틀렸음을 아래를 보면 알 수 있다.
// 642 -> 214 -> 213 -> 71 -> 70 -> 35 -> 34 -> 33 -> 11 -> 10 -> 9 -> 3 -> 1
// 642 -> 214 -> 213 -> 71 -> 70 -> 69 -> 23 -> 22 -> 21 -> 7 -> 6 -> 2 -> 1
// 642 -> 214 -> 107 -> 106 -> 105 -> 35 -> 34 -> 17 -> 16 -> 8 -> 4 -> 2 -> 1 (12)
// 642 -> 214 -> 107 -> 106 -> 53 -> 52 -> 26 -> 13 -> 12 -> 4 -> 2 -> 1 (11) => 3으로 먼저 나눔
// 642 -> 641 -> 640 -> 320 -> 160 -> 80 -> 40 -> 20 -> 10 -> 9 -> 3 -> 1 (11)
// 642 -> 321 -> 320 -> 160 -> 80 -> 40 -> 20 -> 10 -> 9 -> 3 -> 1 (10) => 2로 먼저 나눔

/* 이 코드를 참고한다면 먼저 -1 값을 넣고 이를 3으로 나눈 것과 비교하여 둘중 작은 값을 찾는다. 다음으로 2로 나눈 것과 이전 비교한 값 중 작은 값을 찾는다.
이로써 6의 배수인 경우 -1, 3으로 나눈 값, 2로 나눈 값 세 경우를 모조리 비교하여 가장 작은 값을 찾게 된다.
for i in range(2, X+1):
    d[i] = d[i-1] + 1
        if i % 3 == 0:
    d[i] = min(d[i], d[i//3] + 1)
        if i % 2 == 0:
        d[i] = min(d[i], d[i//2] + 1)
*/

/*
11 -> 10 -> 5 -> 4 -> 2 -> 1
11 -> 10 -> 9 -> 3 -> 2 -> 1

1 -> 1
2 -> 1
3 -> 1
4 -> 2 -> 1
5 -> 4 -> 3 -> 1
5 -> 4 -> 2 -> 1
6 -> 2 -> 1
6 -> 3 -> 1
7 -> 6 -> 2 -> 1
8 -> 4 - > 2 -> 1
16 -> 8 -> 4 -> 2 -> 1 *
16 -> 15 -> 5 -> 4 -> 2 -> 1
17 -> 16 -> 8 -> 4 -> 2 -> 1
17 -> 16 -> 15 -> 5 -> 4 -> 2 -> 1
25 -> 24 -> 12 -> 4 -> 2 -> 1
25 -> 24 -> 8 -> 4 -> 2 -> 1
100 -> 50 -> 25 ->
100 -> 99 -> 33 -> 11 -> 10 -> 9 -> 3 -> 1
 */
